#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# 极空间 Z423 硬盘指示灯守护进程

import time
import os
import re
import subprocess
import fcntl

PORT_CMD = 0x66
PORT_DAT = 0x62

# ==========================================
# 功能开关
# ==========================================
ENABLE_IO_BLINK = False        # True: 绿灯随 IO 读写闪烁；False: 正常盘绿灯常亮

# ==========================================
# 核心状态位
# ==========================================
LED_OFF = 0x00                 # 全灭
LED_GREEN = 0x01               # 绿灯常亮 (正常闲置)
LED_RED = 0x08                 # 红灯常亮 (硬盘故障)
LED_YELLOW = 0x09              # 黄灯常亮 (阵列降级)
LED_YELLOW_FAST_BLINK = 0x24   # 黄灯快闪 (阵列重建)

# 外部命令超时（秒）
SMARTCTL_TIMEOUT = 3
ZPOOL_TIMEOUT = 3

def read_ec(fd, addr):
    """读取 EC 寄存器的实际值"""
    lock_file = '/tmp/z423_ec_port.lock'
    try:
        with open(lock_file, 'w') as f_lock:
            fcntl.flock(f_lock, fcntl.LOCK_EX)
            try:
                os.lseek(fd, PORT_CMD, os.SEEK_SET)
                os.write(fd, b'\x80')
                time.sleep(0.005)
                os.lseek(fd, PORT_DAT, os.SEEK_SET)
                os.write(fd, bytes([addr]))
                time.sleep(0.005)
                os.lseek(fd, PORT_DAT, os.SEEK_SET)
                val = os.read(fd, 1)
                return ord(val) if val else -1
            finally:
                fcntl.flock(f_lock, fcntl.LOCK_UN)
    except Exception:
        return -1

def write_ec(fd, addr, val, verify=True, max_retries=3):
    """写入 EC 寄存器，并可选择是否读取校验"""
    lock_file = '/tmp/z423_ec_port.lock'
    for attempt in range(max_retries):
        try:
            with open(lock_file, 'w') as f_lock:
                fcntl.flock(f_lock, fcntl.LOCK_EX)
                try:
                    os.lseek(fd, PORT_CMD, os.SEEK_SET)
                    os.write(fd, b'\x81')
                    time.sleep(0.005)
                    os.lseek(fd, PORT_DAT, os.SEEK_SET)
                    os.write(fd, bytes([addr]))
                    time.sleep(0.005)
                    os.lseek(fd, PORT_DAT, os.SEEK_SET)
                    os.write(fd, bytes([val]))
                    time.sleep(0.005)
                finally:
                    fcntl.flock(f_lock, fcntl.LOCK_UN)
        except Exception:
            pass
        
        # 如果不需要校验，直接返回 (用于 IO 闪烁提速)
        if not verify:
            return
            
        # 校验写入结果
        if read_ec(fd, addr) == val:
            return
            
        # 校验失败，稍微等待后重试
        time.sleep(0.05)

def get_dynamic_disk_map():
    mapping = {}
    if not os.path.exists('/sys/class/block'):
        return mapping
    for dev in os.listdir('/sys/class/block'):
        if dev.startswith('sd') and not dev[-1].isdigit():
            try:
                path = os.readlink(os.path.join('/sys/class/block', dev))
                if 'usb' in path:
                    continue
                match = re.search(r'/ata(\d+)/', path)
                if match:
                    ata_num = int(match.group(1))
                    if 1 <= ata_num <= 4:
                        mapping[dev] = 0x50 + ata_num
                        continue
                match_host = re.search(r'/host(\d+)/', path)
                if match_host:
                    host_num = int(match_host.group(1))
                    if 0 <= host_num <= 3:
                        mapping[dev] = 0x51 + host_num
            except Exception:
                pass
    return mapping

def get_io_stats(current_map):
    io_state = {}
    try:
        with open('/proc/diskstats', 'r') as f:
            for line in f:
                parts = line.split()
                if len(parts) >= 14:
                    dev = parts[2]
                    if dev in current_map:
                        io_state[dev] = int(parts[3]) + int(parts[7])
    except Exception:
        pass
    return io_state

def check_disk_health(dev):
    # 1) 物理层总线检查
    state_file = f'/sys/block/{dev}/device/state'
    if os.path.exists(state_file):
        try:
            with open(state_file, 'r') as f:
                if f.read().strip() != 'running':
                    return 'fault'
        except Exception:
            pass

    # 2) SMART 检测
    try:
        cmd = ['smartctl', '-n', 'standby', '-H', f'/dev/{dev}']
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=SMARTCTL_TIMEOUT,
        )
        if result.returncode > 2:
            return 'fault'
    except subprocess.TimeoutExpired:
        pass
    except Exception:
        pass

    # 3) ZFS 状态检测
    try:
        identifiers = [dev]
        for disk_dir in ['/dev/disk/by-partuuid', '/dev/disk/by-uuid', '/dev/disk/by-id']:
            if os.path.exists(disk_dir):
                for item in os.listdir(disk_dir):
                    try:
                        target = os.path.basename(os.readlink(os.path.join(disk_dir, item)))
                        if target.startswith(dev):
                            identifiers.append(item)
                    except Exception:
                        pass

        zpool_out = subprocess.check_output(
            ['zpool', 'status'],
            text=True,
            stderr=subprocess.DEVNULL,
            timeout=ZPOOL_TIMEOUT,
        )
        for line in zpool_out.split('\n'):
            for ident in identifiers:
                if ident in line:
                    if 'resilvering' in line:
                        return 'rebuilding'
                    if 'FAULTED' in line or 'UNAVAIL' in line:
                        return 'fault'
                    if 'DEGRADED' in line:
                        return 'degraded'
    except subprocess.TimeoutExpired:
        pass
    except Exception:
        pass

    # 4) 软 RAID 检测
    try:
        if os.path.exists('/proc/mdstat'):
            with open('/proc/mdstat', 'r') as f:
                mdstat = f.read()
                if dev in mdstat:
                    if 'recovery' in mdstat or 'resync' in mdstat:
                        return 'rebuilding'
                    if '_U' in mdstat or 'U_' in mdstat:
                        return 'degraded'
    except Exception:
        pass

    return 'normal'

def main():
    fd = os.open('/dev/port', os.O_RDWR)
    led_addrs = [0x51, 0x52, 0x53, 0x54]
    current_led_state = {}

    # 开机自检
    for addr in led_addrs:
        write_ec(fd, addr, LED_RED_FAST_BLINK)
        current_led_state[addr] = LED_RED_FAST_BLINK
    time.sleep(2)

    last_io = {}
    disk_health = {}
    last_health_check_time = 0

    while True:
        current_time = time.time()
        disk_map = get_dynamic_disk_map()

        # ================= 硬盘热插拔即时处理逻辑 =================
        # 1) 清理已拔出的硬盘缓存
        for dev in list(disk_health.keys()):
            if dev not in disk_map:
                disk_health.pop(dev, None)
                last_io.pop(dev, None)

        # 2) 新插入硬盘：立刻进行一次“入职体检”
        did_instant_check = False
        for dev in disk_map.keys():
            if dev not in disk_health:
                disk_health[dev] = check_disk_health(dev)
                did_instant_check = True

        # 3) 60 秒定期全局巡检
        did_periodic_check = False
        if did_instant_check:
            last_health_check_time = current_time
        elif current_time - last_health_check_time > 60:
            for dev in disk_map.keys():
                disk_health[dev] = check_disk_health(dev)
            last_health_check_time = current_time
            did_periodic_check = True
            
        # 4) 核心防篡改：每次健康检测后，强制读取硬件真实状态并覆盖缓存
        if did_instant_check or did_periodic_check:
            for addr in led_addrs:
                actual_hw_val = read_ec(fd, addr)
                if actual_hw_val != -1:
                    current_led_state[addr] = actual_hw_val
        # ==========================================================

        curr_io = get_io_stats(disk_map)
        active_addrs = []

        for addr in led_addrs:
            dev_for_addr = None
            for dev, mapped_addr in disk_map.items():
                if mapped_addr == addr:
                    dev_for_addr = dev
                    break

            if not dev_for_addr or dev_for_addr not in curr_io:
                if current_led_state.get(addr) != LED_OFF:
                    write_ec(fd, addr, LED_OFF)
                    current_led_state[addr] = LED_OFF
            else:
                dev = dev_for_addr
                health = disk_health.get(dev, 'normal')

                # 经过前面的防篡改读取，如果底层硬件状态不对，这里的 if 判断自然会生效并触发重写
                if health == 'fault':
                    if current_led_state.get(addr) != LED_RED:
                        write_ec(fd, addr, LED_RED)
                        current_led_state[addr] = LED_RED

                elif health == 'degraded':
                    if current_led_state.get(addr) != LED_YELLOW:
                        write_ec(fd, addr, LED_YELLOW)
                        current_led_state[addr] = LED_YELLOW

                elif health == 'rebuilding':
                    if current_led_state.get(addr) != LED_YELLOW_FAST_BLINK:
                        write_ec(fd, addr, LED_YELLOW_FAST_BLINK)
                        current_led_state[addr] = LED_YELLOW_FAST_BLINK

                else:
                    if ENABLE_IO_BLINK and dev in last_io and curr_io[dev] != last_io[dev]:
                        active_addrs.append(addr)
                    else:
                        if current_led_state.get(addr) != LED_GREEN:
                            write_ec(fd, addr, LED_GREEN)
                            current_led_state[addr] = LED_GREEN

        # 执行 IO 闪烁 (禁用校验，确保闪烁速度)
        if active_addrs:
            for addr in active_addrs:
                write_ec(fd, addr, LED_OFF, verify=False)
            time.sleep(0.05)
            for addr in active_addrs:
                write_ec(fd, addr, LED_GREEN, verify=False)
                current_led_state[addr] = LED_GREEN

        last_io = curr_io
        time.sleep(0.2)

if __name__ == '__main__':
    main()
