#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Z423 智能温控守护进程

import time
import os
import fcntl

# ==========================================
# 1. 风扇控制模式
# ==========================================
CPU_FAN_MODE = 'SW_CURVE'   # 'HW_AUTO' | 'SW_CURVE' | 'SW_FIXED'
SYS_FAN_MODE = 'SW_CURVE'   # 'HW_AUTO' | 'SW_CURVE' | 'SW_FIXED'

# ==========================================
# 2. 软件温控配置 (仅在 SW_CURVE 或 SW_FIXED 下生效)
# ==========================================
CPU_MIN_TEMP = 45
CPU_MAX_TEMP = 90
CPU_MIN_PWM = 20
CPU_FIXED_PWM = 40

SYS_MIN_TEMP = 35
SYS_MAX_TEMP = 45
SYS_MIN_PWM = 25
SYS_FIXED_PWM = 40

# ==========================================
# 3. 硬件底层寄存器
# ==========================================
PORT_CMD = 0x66
PORT_DAT = 0x62
REG_CTRL = 0x59
REG_SYS_PWM = 0x5C
REG_CPU_PWM = 0x69

REG_SYS_RPM_H = 0x5E
REG_SYS_RPM_L = 0x5F
REG_CPU_RPM_H = 0x6B
REG_CPU_RPM_L = 0x6C

# 权限分离位掩码 (Bitmask)
BIT_WDG = 0x08
BIT_SYS_AUTO = 0x01
BIT_CPU_AUTO = 0x02

LOCK_FILE = '/tmp/z423_ec_port.lock'

# 锁等待上限，避免别的脚本异常持锁导致本进程永远阻塞
LOCK_TIMEOUT_SEC = 2.0
LOCK_RETRY_SLEEP = 0.01


def acquire_lock():
    start = time.time()
    fd = open(LOCK_FILE, 'a')
    while True:
        try:
            fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            return fd
        except BlockingIOError:
            if time.time() - start >= LOCK_TIMEOUT_SEC:
                fd.close()
                raise TimeoutError("EC lock timeout")
            time.sleep(LOCK_RETRY_SLEEP)


def release_lock(fd):
    try:
        fcntl.flock(fd, fcntl.LOCK_UN)
    finally:
        fd.close()


def write_ec(port_fd, addr, val):
    try:
        lock_fd = acquire_lock()
    except Exception:
        return
    try:
        os.lseek(port_fd, PORT_CMD, os.SEEK_SET)
        os.write(port_fd, b'\x81')
        time.sleep(0.005)
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        os.write(port_fd, bytes([addr]))
        time.sleep(0.005)
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        os.write(port_fd, bytes([val]))
        time.sleep(0.005)
    except Exception:
        pass
    finally:
        release_lock(lock_fd)


def read_ec(port_fd, addr):
    try:
        lock_fd = acquire_lock()
    except Exception:
        return 0
    try:
        os.lseek(port_fd, PORT_CMD, os.SEEK_SET)
        os.write(port_fd, b'\x80')
        time.sleep(0.005)
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        os.write(port_fd, bytes([addr]))
        time.sleep(0.005)
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        val = os.read(port_fd, 1)
        return val[0] if val else 0
    except Exception:
        return 0
    finally:
        release_lock(lock_fd)


def get_fan_rpm(port_fd, addr_h, addr_l):
    val_h = read_ec(port_fd, addr_h)
    val_l = read_ec(port_fd, addr_l)
    rpm = (val_h << 8) | val_l
    return rpm if rpm < 10000 else 0


def get_cpu_temp():
    # 动态寻找 AMD k10temp 传感器
    try:
        for i in range(40):
            name_path = f'/sys/class/hwmon/hwmon{i}/name'
            if os.path.exists(name_path):
                with open(name_path, 'r') as f:
                    if 'k10temp' in f.read():
                        temp_path = f'/sys/class/hwmon/hwmon{i}/temp1_input'
                        if os.path.exists(temp_path):
                            with open(temp_path, 'r') as f_t:
                                return int(f_t.read()) / 1000.0
    except Exception:
        pass
    return 50.0


def _read_temp_input(path):
    # hwmon temp*_input 单位通常是毫摄氏度
    try:
        with open(path, 'r') as f:
            v = int(f.read().strip())
        if v > 1000:
            return v / 1000.0
        return float(v)
    except Exception:
        return None


def get_max_drive_temp_from_drivetemp():
    """
    从内核 drivetemp hwmon 读取硬盘温度（不调用 smartctl）。
    兼容你截图里的:
      /sys/class/hwmon/hwmonX/name == 'drivetemp_scsi_3_0' (或类似)
    取所有 drivetemp* 的 temp*_input 最大值作为 HDD 温度。
    """
    max_temp = None
    hwmon_root = '/sys/class/hwmon'
    try:
        for entry in os.listdir(hwmon_root):
            name_path = os.path.join(hwmon_root, entry, 'name')
            if not os.path.exists(name_path):
                continue
            with open(name_path, 'r') as f:
                name = f.read().strip().lower()

            # 常见命名：drivetemp_scsi_3_0 / drivetemp-scsi-3-0（显示层不同）
            if not name.startswith('drivetemp'):
                continue

            # 扫 temp1_input, temp2_input...
            base = os.path.join(hwmon_root, entry)
            for fn in os.listdir(base):
                if fn.startswith('temp') and fn.endswith('_input'):
                    t = _read_temp_input(os.path.join(base, fn))
                    if t is None:
                        continue
                    if (max_temp is None) or (t > max_temp):
                        max_temp = t
    except Exception:
        pass

    # 兜底：没有 drivetemp 就给个保守值，避免风扇过低
    return max_temp if max_temp is not None else 40.0


def calc_pwm(temp, min_t, max_t, min_pwm):
    if temp <= min_t:
        return int(min_pwm)
    if temp >= max_t:
        return 100
    return int(min_pwm + (100 - min_pwm) * (temp - min_t) / (max_t - min_t))


def calc_ctrl_val():
    ctrl_val = BIT_WDG
    if CPU_FAN_MODE == 'HW_AUTO':
        ctrl_val |= BIT_CPU_AUTO
    if SYS_FAN_MODE == 'HW_AUTO':
        ctrl_val |= BIT_SYS_AUTO
    return ctrl_val


def main():
    port_fd = os.open('/dev/port', os.O_RDWR)
    print("Z423 Fan Daemon Started.", flush=True)

    # 只在启动时写一次控制模式（或模式变化时再写）
    last_ctrl_val = None

    try:
        while True:
            # 1) 控制权寄存器：只在需要时写（启动/模式变化）
            ctrl_val = calc_ctrl_val()
            if ctrl_val != last_ctrl_val:
                write_ec(port_fd, REG_CTRL, ctrl_val)
                last_ctrl_val = ctrl_val

            # 2) 读取温度
            cpu_t = get_cpu_temp()
            hdd_t = get_max_drive_temp_from_drivetemp()

            # 3) CPU 风扇逻辑
            if CPU_FAN_MODE == 'SW_CURVE':
                cpu_pwm = calc_pwm(cpu_t, CPU_MIN_TEMP, CPU_MAX_TEMP, CPU_MIN_PWM)
                write_ec(port_fd, REG_CPU_PWM, cpu_pwm)
                cpu_info = f"[SW_CURVE: {cpu_pwm:3d}%]"
            elif CPU_FAN_MODE == 'SW_FIXED':
                cpu_pwm = CPU_FIXED_PWM
                write_ec(port_fd, REG_CPU_PWM, cpu_pwm)
                cpu_info = f"[SW_FIXED: {cpu_pwm:3d}%]"
            else:
                cpu_pwm = None
                cpu_info = "[HW_AUTO:  EC%]"

            # 4) 机箱/硬盘风扇逻辑
            if SYS_FAN_MODE == 'SW_CURVE':
                sys_pwm = calc_pwm(hdd_t, SYS_MIN_TEMP, SYS_MAX_TEMP, SYS_MIN_PWM)
                write_ec(port_fd, REG_SYS_PWM, sys_pwm)
                sys_info = f"[SW_CURVE: {sys_pwm:3d}%]"
            elif SYS_FAN_MODE == 'SW_FIXED':
                sys_pwm = SYS_FIXED_PWM
                write_ec(port_fd, REG_SYS_PWM, sys_pwm)
                sys_info = f"[SW_FIXED: {sys_pwm:3d}%]"
            else:
                sys_pwm = None
                sys_info = "[HW_AUTO:  EC%]"

            # 5) 读取真实转速
            cpu_rpm = get_fan_rpm(port_fd, REG_CPU_RPM_H, REG_CPU_RPM_L)
            sys_rpm = get_fan_rpm(port_fd, REG_SYS_RPM_H, REG_SYS_RPM_L)

            print(
                f"CPU: {cpu_t:2.0f}°C {cpu_info} -> {cpu_rpm:4d} RPM | "
                f"HDD: {hdd_t:2.0f}°C {sys_info} -> {sys_rpm:4d} RPM",
                flush=True
            )

            time.sleep(10)

    except KeyboardInterrupt:
        pass
    finally:
        # 安全退出：恢复原厂纯硬件控制
        write_ec(port_fd, REG_CTRL, BIT_WDG | BIT_CPU_AUTO | BIT_SYS_AUTO)
        os.close(port_fd)
        print("Daemon Stopped. Full Control returned to EC Hardware.", flush=True)


if __name__ == '__main__':
    main()
