#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Z423 智能温控守护进程

目的：
- 你已验证“停 fan 服务 UPS 不抖”
- 同时监控到 0x59 在 fan 运行时会出现 0x00 等危险值
所以先做最小改动：fan 守护进程运行期间完全不读不写 0x59，
只写 PWM（0x5C/0x69）并可选读 RPM（0x5E/0x5F/0x6B/0x6C）。

保留：
- wait_ec（IBF/OBF）+ flock 锁（减少错位与并发插队概率）
- drivetemp 读盘温
- PWM 变化阈值节流
"""

from __future__ import annotations

import os
import time
import fcntl
from dataclasses import dataclass
from typing import Optional


# ===================== 配置 =====================
CPU_FAN_MODE = "SW_CURVE"  # 'HW_AUTO' | 'SW_CURVE' | 'SW_FIXED'
SYS_FAN_MODE = "SW_CURVE"  # 'HW_AUTO' | 'SW_CURVE' | 'SW_FIXED'

CPU_MIN_TEMP = 45
CPU_MAX_TEMP = 90
CPU_MIN_PWM = 20
CPU_FIXED_PWM = 40

SYS_MIN_TEMP = 35
SYS_MAX_TEMP = 45
SYS_MIN_PWM = 25
SYS_FIXED_PWM = 40

MAIN_INTERVAL_SEC = 60
PWM_WRITE_DELTA = 3

# 设为 False 可进一步减少 EC 读操作（如果你怀疑“读 RPM 也会扰动”）
ENABLE_RPM_READ = True


# ===================== EC 寄存器/端口 =====================
PORT_CMD = 0x66
PORT_DAT = 0x62

REG_SYS_PWM = 0x5C
REG_CPU_PWM = 0x69

REG_SYS_RPM_H = 0x5E
REG_SYS_RPM_L = 0x5F
REG_CPU_RPM_H = 0x6B
REG_CPU_RPM_L = 0x6C

LOCK_FILE = "/tmp/z423_ec_port.lock"
LOCK_TIMEOUT_SEC = 2.0
LOCK_RETRY_SLEEP_SEC = 0.01

EC_STATUS_OBF = 0x01
EC_STATUS_IBF = 0x02

EC_WAIT_STEP_SEC = 0.001
EC_WAIT_TIMEOUT_SEC = 1.0


def clamp_int(v: int, lo: int, hi: int) -> int:
    return lo if v < lo else hi if v > hi else v


# ===================== 锁 =====================
def acquire_lock():
    start = time.time()
    fd = open(LOCK_FILE, "a")
    while True:
        try:
            fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            return fd
        except BlockingIOError:
            if time.time() - start >= LOCK_TIMEOUT_SEC:
                fd.close()
                raise TimeoutError("EC lock timeout")
            time.sleep(LOCK_RETRY_SLEEP_SEC)


def release_lock(fd) -> None:
    try:
        fcntl.flock(fd, fcntl.LOCK_UN)
    finally:
        fd.close()


# ===================== EC wait =====================
def _read_ec_status_locked(port_fd: int) -> Optional[int]:
    try:
        os.lseek(port_fd, PORT_CMD, os.SEEK_SET)
        b = os.read(port_fd, 1)
        return b[0] if b else None
    except Exception:
        return None


def _wait_until_locked(port_fd: int, predicate) -> bool:
    deadline = time.time() + EC_WAIT_TIMEOUT_SEC
    while time.time() < deadline:
        st = _read_ec_status_locked(port_fd)
        if st is not None and predicate(st):
            return True
        time.sleep(EC_WAIT_STEP_SEC)
    return False


def _wait_ibf_clear_locked(port_fd: int) -> bool:
    return _wait_until_locked(port_fd, lambda st: (st & EC_STATUS_IBF) == 0)


def _wait_obf_set_locked(port_fd: int) -> bool:
    return _wait_until_locked(port_fd, lambda st: (st & EC_STATUS_OBF) != 0)


# ===================== EC 访问 =====================
def write_ec(port_fd: int, addr: int, val: int) -> bool:
    try:
        lock_fd = acquire_lock()
    except Exception:
        return False

    try:
        if not _wait_ibf_clear_locked(port_fd):
            return False
        os.lseek(port_fd, PORT_CMD, os.SEEK_SET)
        os.write(port_fd, b"\x81")

        if not _wait_ibf_clear_locked(port_fd):
            return False
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        os.write(port_fd, bytes([addr & 0xFF]))

        if not _wait_ibf_clear_locked(port_fd):
            return False
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        os.write(port_fd, bytes([val & 0xFF]))

        return True
    except Exception:
        return False
    finally:
        release_lock(lock_fd)


def read_ec(port_fd: int, addr: int) -> Optional[int]:
    try:
        lock_fd = acquire_lock()
    except Exception:
        return None

    try:
        if not _wait_ibf_clear_locked(port_fd):
            return None
        os.lseek(port_fd, PORT_CMD, os.SEEK_SET)
        os.write(port_fd, b"\x80")

        if not _wait_ibf_clear_locked(port_fd):
            return None
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        os.write(port_fd, bytes([addr & 0xFF]))

        if not _wait_obf_set_locked(port_fd):
            return None
        os.lseek(port_fd, PORT_DAT, os.SEEK_SET)
        b = os.read(port_fd, 1)
        return b[0] if b else None
    except Exception:
        return None
    finally:
        release_lock(lock_fd)


def get_fan_rpm(port_fd: int, addr_h: int, addr_l: int) -> int:
    vh = read_ec(port_fd, addr_h)
    vl = read_ec(port_fd, addr_l)
    if vh is None or vl is None:
        return 0
    rpm = (vh << 8) | vl
    return rpm if rpm < 10000 else 0


# ===================== 温度读取 =====================
def get_cpu_temp() -> float:
    try:
        for i in range(60):
            name_path = f"/sys/class/hwmon/hwmon{i}/name"
            if os.path.exists(name_path):
                with open(name_path, "r") as f:
                    if "k10temp" in f.read():
                        temp_path = f"/sys/class/hwmon/hwmon{i}/temp1_input"
                        if os.path.exists(temp_path):
                            with open(temp_path, "r") as f_t:
                                return int(f_t.read().strip()) / 1000.0
    except Exception:
        pass
    return 50.0


def _read_temp_input(path: str) -> Optional[float]:
    try:
        with open(path, "r") as f:
            v = int(f.read().strip())
        return v / 1000.0 if v > 1000 else float(v)
    except Exception:
        return None


def get_max_drive_temp_from_drivetemp() -> float:
    max_temp: Optional[float] = None
    hwmon_root = "/sys/class/hwmon"
    try:
        for entry in os.listdir(hwmon_root):
            name_path = os.path.join(hwmon_root, entry, "name")
            if not os.path.exists(name_path):
                continue
            with open(name_path, "r") as f:
                name = f.read().strip().lower()
            if not name.startswith("drivetemp"):
                continue

            base = os.path.join(hwmon_root, entry)
            for fn in os.listdir(base):
                if fn.startswith("temp") and fn.endswith("_input"):
                    t = _read_temp_input(os.path.join(base, fn))
                    if t is None:
                        continue
                    if max_temp is None or t > max_temp:
                        max_temp = t
    except Exception:
        pass

    return max_temp if max_temp is not None else 40.0


# ===================== 控制逻辑 =====================
def calc_pwm(temp: float, min_t: float, max_t: float, min_pwm: int) -> int:
    if temp <= min_t:
        return int(min_pwm)
    if temp >= max_t:
        return 100
    return int(min_pwm + (100 - min_pwm) * (temp - min_t) / (max_t - min_t))


@dataclass
class FanState:
    last_cpu_pwm: Optional[int] = None
    last_sys_pwm: Optional[int] = None


def maybe_write_pwm(port_fd: int, reg: int, new_pwm: int, last_pwm: Optional[int]) -> int:
    new_pwm = clamp_int(int(new_pwm), 0, 100)
    if last_pwm is not None and abs(new_pwm - last_pwm) < PWM_WRITE_DELTA:
        return last_pwm
    write_ec(port_fd, reg, new_pwm)
    return new_pwm


def main() -> None:
    port_fd = os.open("/dev/port", os.O_RDWR)
    print("Z423 Fan Daemon Started.", flush=True)

    st = FanState()

    try:
        while True:
            cpu_t = get_cpu_temp()
            hdd_t = get_max_drive_temp_from_drivetemp()

            # CPU fan
            if CPU_FAN_MODE == "SW_CURVE":
                cpu_pwm = calc_pwm(cpu_t, CPU_MIN_TEMP, CPU_MAX_TEMP, CPU_MIN_PWM)
                st.last_cpu_pwm = maybe_write_pwm(port_fd, REG_CPU_PWM, cpu_pwm, st.last_cpu_pwm)
                cpu_info = f"[SW_CURVE: {st.last_cpu_pwm:3d}%]"
            elif CPU_FAN_MODE == "SW_FIXED":
                st.last_cpu_pwm = maybe_write_pwm(port_fd, REG_CPU_PWM, CPU_FIXED_PWM, st.last_cpu_pwm)
                cpu_info = f"[SW_FIXED: {st.last_cpu_pwm:3d}%]"
            else:
                cpu_info = "[HW_AUTO:  (no pwm writes)]"

            # SYS fan
            if SYS_FAN_MODE == "SW_CURVE":
                sys_pwm = calc_pwm(hdd_t, SYS_MIN_TEMP, SYS_MAX_TEMP, SYS_MIN_PWM)
                st.last_sys_pwm = maybe_write_pwm(port_fd, REG_SYS_PWM, sys_pwm, st.last_sys_pwm)
                sys_info = f"[SW_CURVE: {st.last_sys_pwm:3d}%]"
            elif SYS_FAN_MODE == "SW_FIXED":
                st.last_sys_pwm = maybe_write_pwm(port_fd, REG_SYS_PWM, SYS_FIXED_PWM, st.last_sys_pwm)
                sys_info = f"[SW_FIXED: {st.last_sys_pwm:3d}%]"
            else:
                sys_info = "[HW_AUTO:  (no pwm writes)]"

            if ENABLE_RPM_READ:
                cpu_rpm = get_fan_rpm(port_fd, REG_CPU_RPM_H, REG_CPU_RPM_L)
                sys_rpm = get_fan_rpm(port_fd, REG_SYS_RPM_H, REG_SYS_RPM_L)
                print(
                    f"CPU: {cpu_t:2.0f}°C {cpu_info} -> {cpu_rpm:4d} RPM | "
                    f"HDD: {hdd_t:2.0f}°C {sys_info} -> {sys_rpm:4d} RPM",
                    flush=True,
                )
            else:
                print(
                    f"CPU: {cpu_t:2.0f}°C {cpu_info} | HDD: {hdd_t:2.0f}°C {sys_info}",
                    flush=True,
                )

            time.sleep(MAIN_INTERVAL_SEC)

    except KeyboardInterrupt:
        pass
    finally:
        os.close(port_fd)
        print("Daemon Stopped.", flush=True)


if __name__ == "__main__":
    main()
